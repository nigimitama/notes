<!DOCTYPE html>
<html>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-GXSWJY51EG"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-GXSWJY51EG');
  </script>

  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

  <script src="https://kit.fontawesome.com/95678975f3.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">

  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Frank+Ruhl+Libre|Roboto" rel="stylesheet">
  <link href="modules/progress-nav/normalize.css" rel="stylesheet" type="text/css" />
  <link href="modules/progress-nav/style.css" rel="stylesheet" type="text/css" />

    <meta name="dcterms.date" content="2020-10-01">
  <title>盆暗の勉強メモ – データの前処理で並列処理を使う</title>
  <style type="text/css">code{white-space: pre;}</style>

  <style type="text/css">
    a.sourceLine { display: inline-block; line-height: 1.25; }
    a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
    a.sourceLine:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode { white-space: pre; position: relative; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    code.sourceCode { white-space: pre-wrap; }
    a.sourceLine { text-indent: -1em; padding-left: 1em; }
    }
    pre.numberSource a.sourceLine
      { position: relative; left: -4em; }
    pre.numberSource a.sourceLine::before
      { content: attr(title);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; pointer-events: all; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { background-color: #f8f8f8; }
    @media screen {
    a.sourceLine::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #c4a000; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #000000; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #000000; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #000000; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>


  <link rel="stylesheet" href="modules/style.css">



</head>
<body>
<header>
    <div class="logo-area p-4">
        <a href="index.html">盆暗の勉強メモ</a>
    </div>

    <nav class="navbar px-4 py-1 navbar-expand navbar-light bg-light">
        <ul class="navbar-nav">
            <li class="nav-item"><a class="nav-link" href="data_science.html"><i class="fas fa-chart-bar"></i> Data Science</a></li>
            <li class="nav-item"><a class="nav-link" href="engineering.html"><i class="fas fa-file-code"></i> Software Engineering</a></li>
            <li class="nav-item"><a class="nav-link" href="mathematics.html"><i class="fas fa-square-root-alt"></i> Mathematics</a></li>
        </ul>
    </nav>
</header>  <main class="py-2">
  <!-- table of contents -->
      <nav class="toc" id="TOC">
    <ul>
    <li><a href="#コード例">コード例</a><ul>
    <li><a href="#processクラスとpipeクラスを使う場合">ProcessクラスとPipeクラスを使う場合</a></li>
    <li><a href="#poolクラスを使う場合">Poolクラスを使う場合</a></li>
    </ul></li>
    <li><a href="#なぜmultiprocessingなのか">なぜmultiprocessingなのか</a></li>
    </ul>
      <!-- svg for progress-nav -->
      <svg class="toc-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
        <path stroke="dimgray" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
      </svg>
    </nav>
    
  <!-- main contents -->
    
    <!-- contents header -->
        <div>
      <h1 class="title">データの前処理で並列処理を使う</h1>
                        <p class="date">2020-10-01</p>
          </div>
    
    <!-- contents body -->
    <article class="contents">
<p>pythonのmultiprocessingパッケージについてのメモ。</p>
<h1 id="コード例">コード例</h1>
<p>こう書けば良いんじゃないかな、と思った実装例を載せていきます。</p>
<p>以下では説明の簡単のために’x’というカラムを2倍にするだけのdoubleという関数を並列処理にしていますが、実際にはWeb APIを呼び出すときに使ったりします。</p>
<h2 id="processクラスとpipeクラスを使う場合">ProcessクラスとPipeクラスを使う場合</h2>
<p>処理するデータを明示的に分割して別々のプロセスで処理する場合。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="im">import</span> pandas <span class="im">as</span> pd</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="im">from</span> multiprocessing <span class="im">import</span> Process, Pipe</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">def</span> double(conn) <span class="op">-&gt;</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="co">&#39;&#39;&#39;親プロセスからデータを受け取って処理して送り返す&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-7" title="7">    records <span class="op">=</span> conn.recv()</a>
<a class="sourceLine" id="cb1-8" title="8">    records <span class="op">=</span> <span class="bu">map</span>(_double, records)</a>
<a class="sourceLine" id="cb1-9" title="9">    conn.send(records)</a>
<a class="sourceLine" id="cb1-10" title="10">    conn.close()</a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="kw">def</span> _double(record: <span class="bu">dict</span>) <span class="op">-&gt;</span> <span class="bu">dict</span>:</a>
<a class="sourceLine" id="cb1-15" title="15">    <span class="co">&#39;&#39;&#39;xというカラムを2倍にする&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-16" title="16">    record[<span class="st">&#39;x&#39;</span>] <span class="op">=</span> record[<span class="st">&#39;x&#39;</span>] <span class="op">*</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-17" title="17">    <span class="cf">return</span> record</a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19"></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="kw">def</span> multipocess(df: pd.DataFrame, n_workers: <span class="bu">int</span>) <span class="op">-&gt;</span> pd.DataFrame:</a>
<a class="sourceLine" id="cb1-21" title="21">    <span class="co"># DataFrameを送ることはできないのでdictのListにする</span></a>
<a class="sourceLine" id="cb1-22" title="22">    records <span class="op">=</span> df.to_dict(<span class="st">&#39;records&#39;</span>)</a>
<a class="sourceLine" id="cb1-23" title="23"></a>
<a class="sourceLine" id="cb1-24" title="24">    <span class="co"># データを分割</span></a>
<a class="sourceLine" id="cb1-25" title="25">    size <span class="op">=</span> <span class="bu">len</span>(records) <span class="op">//</span> n_workers <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-26" title="26">    records_list <span class="op">=</span> _each_slice(records, size)</a>
<a class="sourceLine" id="cb1-27" title="27"></a>
<a class="sourceLine" id="cb1-28" title="28">    parent_conns <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> n_workers</a>
<a class="sourceLine" id="cb1-29" title="29">    child_conns <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> n_workers</a>
<a class="sourceLine" id="cb1-30" title="30">    processes <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> n_workers</a>
<a class="sourceLine" id="cb1-31" title="31">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_workers):</a>
<a class="sourceLine" id="cb1-32" title="32">        <span class="co"># 子プロセスにデータを送るためのPipeを作成</span></a>
<a class="sourceLine" id="cb1-33" title="33">        parent_conns[i], child_conns[i] <span class="op">=</span> Pipe()</a>
<a class="sourceLine" id="cb1-34" title="34">        <span class="co"># 子プロセスを作成</span></a>
<a class="sourceLine" id="cb1-35" title="35">        processes[i] <span class="op">=</span> Process(</a>
<a class="sourceLine" id="cb1-36" title="36">            target<span class="op">=</span>double,</a>
<a class="sourceLine" id="cb1-37" title="37">            args<span class="op">=</span>(child_conns[i],)</a>
<a class="sourceLine" id="cb1-38" title="38">        )</a>
<a class="sourceLine" id="cb1-39" title="39">        <span class="co"># 子プロセスにデータを送る</span></a>
<a class="sourceLine" id="cb1-40" title="40">        parent_conns[i].send(records_list[i])</a>
<a class="sourceLine" id="cb1-41" title="41">        <span class="co"># 子プロセスの処理を開始</span></a>
<a class="sourceLine" id="cb1-42" title="42">        processes[i].start()</a>
<a class="sourceLine" id="cb1-43" title="43"></a>
<a class="sourceLine" id="cb1-44" title="44">    results <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> n_workers</a>
<a class="sourceLine" id="cb1-45" title="45">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_workers):</a>
<a class="sourceLine" id="cb1-46" title="46">        <span class="co"># 子プロセスから結果を受け取り</span></a>
<a class="sourceLine" id="cb1-47" title="47">        results[i] <span class="op">=</span> parent_conns[i].recv()</a>
<a class="sourceLine" id="cb1-48" title="48">        <span class="co"># 子プロセスをjoin</span></a>
<a class="sourceLine" id="cb1-49" title="49">        processes[i].join(timeout<span class="op">=</span><span class="dv">10</span>)</a>
<a class="sourceLine" id="cb1-50" title="50"></a>
<a class="sourceLine" id="cb1-51" title="51">    df_list <span class="op">=</span> [pd.DataFrame(res) <span class="cf">for</span> res <span class="kw">in</span> results]</a>
<a class="sourceLine" id="cb1-52" title="52">    <span class="cf">return</span> pd.concat(df_list).reset_index(drop<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb1-53" title="53"></a>
<a class="sourceLine" id="cb1-54" title="54"></a>
<a class="sourceLine" id="cb1-55" title="55"><span class="kw">def</span> _each_slice(arr: <span class="bu">list</span>, size: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">list</span>:</a>
<a class="sourceLine" id="cb1-56" title="56">    <span class="co">&#39;&#39;&#39;listを要素数sizeのリストに分割する&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-57" title="57">    <span class="cf">return</span> [arr[i:i <span class="op">+</span> size] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(arr), size)]</a>
<a class="sourceLine" id="cb1-58" title="58"></a>
<a class="sourceLine" id="cb1-59" title="59"></a>
<a class="sourceLine" id="cb1-60" title="60"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</a>
<a class="sourceLine" id="cb1-61" title="61">    <span class="co"># データを用意</span></a>
<a class="sourceLine" id="cb1-62" title="62">    df <span class="op">=</span> pd.DataFrame({<span class="st">&#39;x&#39;</span>: <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">10</span>))})</a>
<a class="sourceLine" id="cb1-63" title="63">    <span class="co"># 並列処理</span></a>
<a class="sourceLine" id="cb1-64" title="64">    df <span class="op">=</span> multipocess(df, n_workers<span class="op">=</span><span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1-65" title="65">    <span class="bu">print</span>(df)</a></code></pre></div>
<p>結果</p>
<pre><code>    x
0   0
1   2
2   4
3   6
4   8
5  10
6  12
7  14
8  16
9  18</code></pre>
<h2 id="poolクラスを使う場合">Poolクラスを使う場合</h2>
<p>データを分けて複数のプロセスを管理して‥という作業をPoolクラスに任せる場合。</p>
<p>こっちのほうが楽です。</p>
<p>ただ、使えない環境もあります。AWS Lambdaではプロセスの共有メモリがサポートされていないのでPoolクラスはエラーを起こします。その場合は面倒ですが前節のPipeクラスを使う必要があります<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="im">import</span> pandas <span class="im">as</span> pd</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="im">from</span> multiprocessing <span class="im">import</span> Pool</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">def</span> double(record: <span class="bu">dict</span>) <span class="op">-&gt;</span> <span class="bu">dict</span>:</a>
<a class="sourceLine" id="cb3-6" title="6">    record[<span class="st">&#39;x&#39;</span>] <span class="op">=</span> record[<span class="st">&#39;x&#39;</span>] <span class="op">*</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="cf">return</span> record</a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="co"># データを用意</span></a>
<a class="sourceLine" id="cb3-12" title="12">    df <span class="op">=</span> pd.DataFrame({<span class="st">&#39;x&#39;</span>: <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">10</span>))})</a>
<a class="sourceLine" id="cb3-13" title="13">    <span class="co"># DataFrameを送ることはできないのでdictのListにする</span></a>
<a class="sourceLine" id="cb3-14" title="14">    records <span class="op">=</span> df.to_dict(<span class="st">&#39;records&#39;</span>)</a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="co"># 並列処理</span></a>
<a class="sourceLine" id="cb3-17" title="17">    n_workers <span class="op">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb3-18" title="18">    <span class="cf">with</span> Pool(n_workers) <span class="im">as</span> pool:</a>
<a class="sourceLine" id="cb3-19" title="19">        results <span class="op">=</span> pool.<span class="bu">map</span>(double, records)</a>
<a class="sourceLine" id="cb3-20" title="20"></a>
<a class="sourceLine" id="cb3-21" title="21">    df <span class="op">=</span> pd.DataFrame(results)</a>
<a class="sourceLine" id="cb3-22" title="22">    <span class="bu">print</span>(df)</a></code></pre></div>
<p>結果</p>
<pre><code>    x
0   0
1   2
2   4
3   6
4   8
5  10
6  12
7  14
8  16
9  18</code></pre>
<h1 id="なぜmultiprocessingなのか">なぜmultiprocessingなのか</h1>
<p>ちなみに、なぜmultiprocessingなのかというと、pandasがmultithreadに非対応なので<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>、並列処理する関数の中でpandasも使えるという実装の自由度を考えるとデータ処理で使うにはmultiprocessingのほうが相性が良いのかなと思っています。pandasを使わないのであればmultithreadでいいかもしれません。</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://aws.amazon.com/jp/blogs/compute/parallel-processing-in-python-with-aws-lambda/">Parallel Processing in Python with AWS Lambda | AWS Compute Blog</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/gotchas.html#thread-safety">Frequently Asked Questions (FAQ) — pandas 1.1.3 documentation</a>。ここではver.0.11の話をしていますが、私は0.25.3時代に実際にmultithreadを試して上手く行かなかった経験があります。おそらく1.1.3現在も変わらないはず。<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section> <!-- NOTE: ここにインデントをつけるとcode部のインデントが壊れる -->
    </article>
    
      </main>

  <script src="modules/progress-nav/script.js"></script>
</body>
</html>