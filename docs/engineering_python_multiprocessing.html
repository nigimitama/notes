<!DOCTYPE html>
<html>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-GXSWJY51EG"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-GXSWJY51EG');
  </script>

  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

  <script src="https://kit.fontawesome.com/95678975f3.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">

  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Frank+Ruhl+Libre|Roboto" rel="stylesheet">
  <link href="modules/progress-nav/normalize.css" rel="stylesheet" type="text/css" />
  <link href="modules/progress-nav/style.css" rel="stylesheet" type="text/css" />

    <meta name="dcterms.date" content="2020-10-01">
  <title>盆暗の勉強メモ – データの前処理で並列処理を使う</title>
  <style type="text/css">code{white-space: pre;}</style>

  <style type="text/css">
    div.sourceCode { overflow-x: auto; }
    table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
      margin: 0; padding: 0; vertical-align: baseline; border: none; }
    table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
    td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
    td.sourceCode { padding-left: 5px; }
    pre, code { background-color: #f8f8f8; }
    code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code > span.dt { color: #204a87; } /* DataType */
    code > span.dv { color: #0000cf; } /* DecVal */
    code > span.bn { color: #0000cf; } /* BaseN */
    code > span.fl { color: #0000cf; } /* Float */
    code > span.ch { color: #4e9a06; } /* Char */
    code > span.st { color: #4e9a06; } /* String */
    code > span.co { color: #8f5902; font-style: italic; } /* Comment */
    code > span.ot { color: #8f5902; } /* Other */
    code > span.al { color: #ef2929; } /* Alert */
    code > span.fu { color: #000000; } /* Function */
    code > span.er { color: #a40000; font-weight: bold; } /* Error */
    code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
    code > span.cn { color: #000000; } /* Constant */
    code > span.sc { color: #000000; } /* SpecialChar */
    code > span.vs { color: #4e9a06; } /* VerbatimString */
    code > span.ss { color: #4e9a06; } /* SpecialString */
    code > span.im { } /* Import */
    code > span.va { color: #000000; } /* Variable */
    code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code > span.ex { } /* Extension */
    code > span.at { color: #c4a000; } /* Attribute */
    code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>


  <link rel="stylesheet" href="modules/style.css">



</head>
<body>
  <header>
    <div class="logo-area p-4">
        <a href="index.html">盆暗の勉強メモ</a>
    </div>

    <nav class="navbar px-4 py-1 navbar-expand-lg navbar-light bg-light">
        <ul class="navbar-nav">
            <li class="nav-item"><a class="nav-link" href="data_science.html"><i class="fas fa-chart-bar"></i> Data Science</a></li>
            <li class="nav-item"><a class="nav-link" href="engineering.html"><i class="fas fa-file-code"></i> Software Engineering</a></li>
            <li class="nav-item"><a class="nav-link" href="mathematics.html"><i class="fas fa-square-root-alt"></i> Mathematics</a></li>
        </ul>
    </nav>
</header>
  <main class="py-2">
  <!-- table of contents -->
      <nav class="toc" id="TOC">
    <ul>
    <li><a href="#コード例">コード例</a><ul>
    <li><a href="#processクラスとpipeクラスを使う場合">ProcessクラスとPipeクラスを使う場合</a></li>
    <li><a href="#poolクラスを使う場合">Poolクラスを使う場合</a></li>
    </ul></li>
    <li><a href="#なぜmultiprocessingなのか">なぜmultiprocessingなのか</a></li>
    </ul>
      <!-- svg for progress-nav -->
      <svg class="toc-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
        <path stroke="dimgray" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
      </svg>
    </nav>
    
  <!-- main contents -->
    
    <!-- contents header -->
        <div>
      <h1 class="title">データの前処理で並列処理を使う</h1>
                        <p class="date">2020-10-01</p>
          </div>
    
    <!-- contents body -->
    <article class="contents">
<p>pythonのmultiprocessingパッケージについてのメモ。</p>
<h1 id="コード例">コード例</h1>
<p>こう書けば良いんじゃないかな、と思った実装例を載せていきます。</p>
<p>以下では説明の簡単のために'x'というカラムを2倍にするだけのdoubleという関数を並列処理にしていますが、実際にはWeb APIを呼び出すときに使ったりします。</p>
<h2 id="processクラスとpipeクラスを使う場合">ProcessクラスとPipeクラスを使う場合</h2>
<p>処理するデータを明示的に分割して別々のプロセスで処理する場合。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd
<span class="im">from</span> multiprocessing <span class="im">import</span> Process, Pipe


<span class="kw">def</span> double(conn) <span class="op">-&gt;</span> <span class="va">None</span>:
    <span class="co">&#39;&#39;&#39;親プロセスからデータを受け取って処理して送り返す&#39;&#39;&#39;</span>
    records <span class="op">=</span> conn.recv()
    records <span class="op">=</span> <span class="bu">map</span>(_double, records)
    conn.send(records)
    conn.close()
    <span class="cf">return</span> <span class="va">None</span>


<span class="kw">def</span> _double(record: <span class="bu">dict</span>) <span class="op">-&gt;</span> <span class="bu">dict</span>:
    <span class="co">&#39;&#39;&#39;xというカラムを2倍にする&#39;&#39;&#39;</span>
    record[<span class="st">&#39;x&#39;</span>] <span class="op">=</span> record[<span class="st">&#39;x&#39;</span>] <span class="op">*</span> <span class="dv">2</span>
    <span class="cf">return</span> record


<span class="kw">def</span> multipocess(df: pd.DataFrame, n_workers: <span class="bu">int</span>) <span class="op">-&gt;</span> pd.DataFrame:
    <span class="co"># DataFrameを送ることはできないのでdictのListにする</span>
    records <span class="op">=</span> df.to_dict(<span class="st">&#39;records&#39;</span>)

    <span class="co"># データを分割</span>
    size <span class="op">=</span> <span class="bu">len</span>(records) <span class="op">//</span> n_workers <span class="op">+</span> <span class="dv">1</span>
    records_list <span class="op">=</span> _each_slice(records, size)

    parent_conns <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> n_workers
    child_conns <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> n_workers
    processes <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> n_workers
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_workers):
        <span class="co"># 子プロセスにデータを送るためのPipeを作成</span>
        parent_conns[i], child_conns[i] <span class="op">=</span> Pipe()
        <span class="co"># 子プロセスを作成</span>
        processes[i] <span class="op">=</span> Process(
            target<span class="op">=</span>double,
            args<span class="op">=</span>(child_conns[i],)
        )
        <span class="co"># 子プロセスにデータを送る</span>
        parent_conns[i].send(records_list[i])
        <span class="co"># 子プロセスの処理を開始</span>
        processes[i].start()

    results <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> n_workers
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_workers):
        <span class="co"># 子プロセスから結果を受け取り</span>
        results[i] <span class="op">=</span> parent_conns[i].recv()
        <span class="co"># 子プロセスをjoin</span>
        processes[i].join(timeout<span class="op">=</span><span class="dv">10</span>)

    df_list <span class="op">=</span> [pd.DataFrame(res) <span class="cf">for</span> res <span class="kw">in</span> results]
    <span class="cf">return</span> pd.concat(df_list).reset_index(drop<span class="op">=</span><span class="va">True</span>)


<span class="kw">def</span> _each_slice(arr: <span class="bu">list</span>, size: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">list</span>:
    <span class="co">&#39;&#39;&#39;listを要素数sizeのリストに分割する&#39;&#39;&#39;</span>
    <span class="cf">return</span> [arr[i:i <span class="op">+</span> size] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(arr), size)]


<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:
    <span class="co"># データを用意</span>
    df <span class="op">=</span> pd.DataFrame({<span class="st">&#39;x&#39;</span>: <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">10</span>))})
    <span class="co"># 並列処理</span>
    df <span class="op">=</span> multipocess(df, n_workers<span class="op">=</span><span class="dv">4</span>)
    <span class="bu">print</span>(df)</code></pre></div>
<p>結果</p>
<pre><code>    x
0   0
1   2
2   4
3   6
4   8
5  10
6  12
7  14
8  16
9  18</code></pre>
<h2 id="poolクラスを使う場合">Poolクラスを使う場合</h2>
<p>データを分けて複数のプロセスを管理して‥という作業をPoolクラスに任せる場合。</p>
<p>こっちのほうが楽です。</p>
<p>ただ、使えない環境もあります。AWS Lambdaではプロセスの共有メモリがサポートされていないのでPoolクラスはエラーを起こします。その場合は面倒ですが前節のPipeクラスを使う必要があります<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd
<span class="im">from</span> multiprocessing <span class="im">import</span> Pool


<span class="kw">def</span> double(record: <span class="bu">dict</span>) <span class="op">-&gt;</span> <span class="bu">dict</span>:
    record[<span class="st">&#39;x&#39;</span>] <span class="op">=</span> record[<span class="st">&#39;x&#39;</span>] <span class="op">*</span> <span class="dv">2</span>
    <span class="cf">return</span> record


<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:
    <span class="co"># データを用意</span>
    df <span class="op">=</span> pd.DataFrame({<span class="st">&#39;x&#39;</span>: <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">10</span>))})
    <span class="co"># DataFrameを送ることはできないのでdictのListにする</span>
    records <span class="op">=</span> df.to_dict(<span class="st">&#39;records&#39;</span>)

    <span class="co"># 並列処理</span>
    n_workers <span class="op">=</span> <span class="dv">4</span>
    <span class="cf">with</span> Pool(n_workers) <span class="im">as</span> pool:
        results <span class="op">=</span> pool.<span class="bu">map</span>(double, records)

    df <span class="op">=</span> pd.DataFrame(results)
    <span class="bu">print</span>(df)</code></pre></div>
<p>結果</p>
<pre><code>    x
0   0
1   2
2   4
3   6
4   8
5  10
6  12
7  14
8  16
9  18</code></pre>
<h1 id="なぜmultiprocessingなのか">なぜmultiprocessingなのか</h1>
<p>ちなみに、なぜmultiprocessingなのかというと、pandasがmultithreadに非対応なので<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>、並列処理する関数の中でpandasも使えるという実装の自由度を考えるとデータ処理で使うにはmultiprocessingのほうが相性が良いのかなと思っています。pandasを使わないのであればmultithreadでいいかもしれません。</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://aws.amazon.com/jp/blogs/compute/parallel-processing-in-python-with-aws-lambda/">Parallel Processing in Python with AWS Lambda | AWS Compute Blog</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/gotchas.html#thread-safety">Frequently Asked Questions (FAQ) — pandas 1.1.3 documentation</a>。ここではver.0.11の話をしていますが、私は0.25.3時代に実際にmultithreadを試して上手く行かなかった経験があります。おそらく1.1.3現在も変わらないはず。<a href="#fnref2">↩</a></p></li>
</ol>
</div> <!-- NOTE: ここにインデントをつけるとcode部のインデントが壊れる -->
    </article>
    
      </main>

  <script src="modules/progress-nav/script.js"></script>
</body>
</html>